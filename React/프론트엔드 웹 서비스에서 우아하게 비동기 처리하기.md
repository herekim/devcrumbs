# 프론트엔드 웹 서비스에서 우아하게 비동기 처리하기

- 비동기 처리가 콜백보다 async&await가 좋은 코드인 이유는 '성공하는 경우'만 다루고, '실패하는 경우'는 외부로 위임할 수 있기 때문
- swr, react-query에서 비동기 처리는 컴포넌트에서 로딩, 성공, 에러처리가 함께 수행되고 있음
- 우아하게 처리하기 위한 대안 'React Suspense for Data Fetching'
- 어떤 코드가 목표인가?
  - 성공한 경우에만 집중할 수 있는
  - 로딩 상태와 에러 상태가 분리된
  - 동기와 거의 같게 사용할 수 있는
- 어떻게 에러 상태와 로딩 상태가 분리되는가?
  - 컴포넌트를 '쓰는 쪽'에서 로딩 처리와 에러 처리를 한다
  - 로딩 상태는 가장 가까운 'Suspense'의 'Fallback'으로 그려진다
  - 에러 상태는 가장 가까운 'ErrorBoundary'가 componentDidCatch()로 처리한다
  - 예시 코드
    ```jsx
    <ErrorBoundary fallback={<ErrorPage />}>
      <Suspense fallback={<Loader />}>
        <App />
      </Suspense>
    </ErrorBoundary>
    ```

## 하지 못한 이야기들 (유저 경험 상승)

- React Concurrent Mode
- useTransition, useDeferredValue

### 참고자료

[프론트엔드 웹 서비스에서 우아하게 비동기 처리하기(링크) - 박서진](https://toss.im/slash-21/sessions/3-1)
[프론트엔드 웹 서비스에서 우아하게 비동기 처리하기(발표자료) - 박서진](https://static.toss.im/slash21/pdf/[%ED%86%A0%EC%8A%A4_SLASH%2021]%20%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EC%9B%B9%20%EC%84%9C%EB%B9%84%EC%8A%A4%EC%97%90%EC%84%9C%20%EC%9A%B0%EC%95%84%ED%95%98%EA%B2%8C%20%EB%B9%84%EB%8F%99%EA%B8%B0%20%EC%B2%98%EB%A6%AC%ED%95%98%EA%B8%B0_%EB%B0%95%EC%84%9C%EC%A7%84.pdf)
[데이터를 가져오기 위한 Suspense](https://ko.reactjs.org/docs/concurrent-mode-suspense.html)
[React Team Sebastian Markbage의 Proof-of-concept](https://gist.github.com/sebmarkbage)
[대수적 효과](https://overreacted.io/algebraic-effects-for-the-rest-of-us/)

# 브라우저 호환성과 빌드 환경
[실제 적용 프로젝트](https://github.com/f-lab-edu/froggy-jump)

## 알아볼 것

1. 브라우저 호환성을 어떻게 지킬까? (Babel)
2. 빌드 환경을 어떻게 구성할까? (Webpack)

## Keyword

- Babel
- Transpiling
- Polyfill
- Webpack
- Bundling

# 브라우저 호환성을 어떻게 지킬까?

- 브라우저마다, 그리고 브라우저 버전마다 특정 코드가 동작하지 않을 수 있다.
- 그렇기 때문에 Bebel을 사용해서 원하는 버전으로 Transpiling을 해준다.
- core-js와 같은 모듈로 polyfill을 해서 원하는 코드를 하위 브라우저에 호환되는 코드로 변환시킨다.
- 이렇게 함으로써 지원 가능한 브라우저의 범위를 특정할 수 있다.

## Transfiling

- Babel이 수행한다. 하위 브라우저에서 동작하게 문법을 바꿔준다.
- 최신기능의 문법, TC39 Process와 같은 제안된 기능, TypeScript, JSX 등의 문법을 원하는 버전의 자바스크립트로 변환한다.
- Babel의 동작원리는 다음과 같다.
  1. 소스코드를 파싱한 뒤에 추상구문트리(AST)를 생성한다.
  2. AST를 각 브라우저에 맞게 변환한다. (Plugin 적용)
  3. 변형된 AST를 실제 브라우저 환경에 맞게 소스코드로 변환한다.

## Polyfill

- Babel로 Transfiling을 한다고 모든 최신 문법을 사용할수는 없다.
- Polyfill을 이용해서 하위 브라우저가 지원하는 형태로 해당 코드를 변환해준다.
- Polyfill은 런타임 환경에서 기능이 주입된다. 즉, 브라우저에서 코드가 실행될 때 해당 코드가 없다면 코드 변환을 해준다. (설정을 통해 모든 Polyfill을 가져올수도 있다)

## Babel 설정 예제

### 1. 설치

```
npm i @babel/core @babel/cli @babel/preset-env babel-plugin-module-resolver -D
```

- [@babel/core](https://babeljs.io/docs/en/babel-core)  
  babel 사용을 위한 기본 패키지.
- [@babel/cli](https://babeljs.io/docs/en/babel-cli)  
  babel에서 제공하는 빌트인 커맨드 명령어.
- [@babel/preset-env](https://babeljs.io/docs/en/babel-preset-env)  
  구체적인 관리없이 최신 자바스크립트를 사용할 수 있도록 하는 Babel 공식 프리셋.
- babel-plugin-module-resolver  
  절대경로 혹은 alias를 사용하기 위한 모듈.

### 2. 실제 적용 예시

적용 조건

1. 전세계 0.25% 이상의 점유율을 가진 브라우저에서 동작 가능하도록 설정.
2. core-js를 사용해 Polyfill 추가.
3. 절대경로 설정을 추가.

```js
module.exports = (api) => {
  api.cache(true)

  const presets = [
    [
      '@babel/preset-env',
      {
        targets: '> 0.25%, not dead',
        useBuiltIns: 'usage',
        corejs: 3,
        modules: false,
      },
    ],
  ]

  const plugins = [
    [
      'module-resolver',
      {
        root: ['./src'],
        alias: {
          imgs: './public/images',
          '@': './',
        },
      },
    ],
  ]

  return {
    presets,
    plugins,
  }
}
```

- api.cache(true)  
  한번만 Babel 설정 파일을 실행하겠다는 의미
- targets:  
  프로젝트가 지원할 환경을 설정
- corejs  
  Polyfill을 지원할 corejs의 버전 설정
- useBuiltIns: 'usage'  
  필요한 Polyfill만 사용하도록 설정
- modules: false  
  true면 ESM을 Commonjs 문법으로 변환
- module-resolver  
  root로 설정된 주소는 `./src/components/test` -> `components/test` 로 import 가능  
  alias는 별명으로, 할당된 주소를 키로 설정한 값으로 대체 가능

### 참고자료

- [추상구문트리(AST)](https://astexplorer.net/#/gist/90bc74fbaaee4050afadca33d2899470/latest)
- [caniuse.com](https://caniuse.com/)

# 빌드환경을 어떻게 구성할까?

![Webpack 동작](https://i.stack.imgur.com/P7hTM.png)

## Webpack은 왜 필요할까?

Webpack은 모듈 번들러. 모듈로 각 파일을 관리함으로써 의존성을 줄여줌. 그러므로 기존에 여러 script를 불러올 때 발생했던 네트워크 병목 문제 해결. 로더, 플러그인을 통해 ES6 이상의 문법을 지원하고, 코드를 압축 & 최적화.

## Webpack의 동작원리

엔트리 파일부터 의존성을 분석해서 종속성 그래프를 만들고, 그래프를 바탕으로 모든 모듈을 하나의 번들링 파일로 합쳐준다.

## 실제 적용 예시

### 1. Webpack 설치

`npm i webpack webpack-cli -D`

### 1. Loader

`npm i babel-loader css-loader sass-loader file-loader url-loader -D`

- Loader란 개별 파일이 번들링되기 전 혹은 번들링 과정에서 모듈을 변형시키는 전처리도구
- Webpack은 모든 파일을 모듈로 관리 (이미지, CSS ...)
- Webpack은 JS만 이해. 그래서 Loader는 이 파일들을 Webpack이 이해할 수 있게 변경

### 2. Plugin 설치

`npm i html-webpack-plugin clean-webpack-plugin mini-css-extract-plugin webpack-merge webpack-dev-server -D`

- Plugin이란 Bundle 생성 과정이 종료된 Bundle, Chunk 레벨에서 작동.
- Bundle이 생성되는 방식을 수정하기도 함.

### 3. 예제 코드

```js
// webpack.common.js
const path = require('path')

const { CleanWebpackPlugin } = require('clean-webpack-plugin')
const HtmlWebpackPlugin = require('html-webpack-plugin')
const MiniCssExtractPlugin = require('mini-css-extract-plugin')

const config = {
  entry: './src/index.js',
  output: {
    path: path.resolve(__dirname, './dist'),
    filename: 'bundle.js',
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        use: 'babel-loader',
        exclude: /node_modules/,
      },
      {
        test: /\.(sa|sc|c)ss$/,
        use: [MiniCssExtractPlugin.loader, 'css-loader', 'sass-loader'],
      },
      {
        test: /\.(png|jpe?g|gif|svg|ico)$/,
        use: [
          {
            loader: 'url-loader',
            options: {
              useRelativePath: true,
              name: 'images/[name].[ext]?[hash]',
              publicPath: './dist/',
              limit: 10000,
            },
          },
        ],
      },
    ],
  },
  plugins: [
    new MiniCssExtractPlugin({
      filename: 'style.css',
    }),
    new HtmlWebpackPlugin({
      template: path.resolve(__dirname, 'public/index.html'),
      filename: path.resolve(__dirname, 'dist/index.html'),
      inject: true,
    }),
    new CleanWebpackPlugin({ filename: 'bundle.js' }),
  ],
}

module.exports = config
```

- `entry`  
  의존성 분석을 시작할 엔트리 파일
- `output`  
  번들링 파일의 위치와 파일 이름 설정
- [`babel-loader`](https://webpack.js.org/loaders/babel-loader/)  
  Babel을 사용해서 Transfililg
- [[MiniCssExtractPlugin.loader](https://webpack.js.org/plugins/mini-css-extract-plugin/), ['css-loader'](https://webpack.js.org/loaders/css-loader/), ['sass-loader'](https://webpack.js.org/loaders/sass-loader/)]  
  CSS 파일을 모듈화. 오른쪽부터 sass, css 파일을 번들링하며, `MiniCssExtractPlugin.loader`는 css 파일을 따로 스타일시트로 빼서 적용시킨다. style-loader를 사용할 경우 번들링된 파일의 헤더에 적용된다.
- [url-loader](https://v4.webpack.js.org/loaders/url-loader/)  
  url-loader는 file-loader를 기반으로 동작하기 때문에 file-loader가 필요하다. file-loader가 파일을 복사해서 해싱하는 방식으로 사용된다면, url-loader는 작은 파일의 경우 base64 문자열로 변환하여 번들링 파일에 넣는다. 결과적으로 더 작은 번들 사이즈를 갖게 된다.
- [HtmlWebpackPlugin](https://webpack.js.org/plugins/html-webpack-plugin/)  
  Webpack 번들에 HTML 파일을 단순하게 추가. 따로 분리하여 번들한 css파일과 js파일을 각각 html 파일에 link 태그, script태그로 추가. 특히 번들링된 파일에 해시값을 가지고 있을 때 유용. HTML을 만들 때 템플릿과 파일 이름 뿐 아니라, 주입을 해제하고 직업 메타나 타이틀 등의 설정을 해줄 수 있음.
- [CleanWebpackPlugin](https://www.npmjs.com/package/clean-webpack-plugin)  
  CleanWebpackPlugin은 빌드 이전 결과물을 제거

```js
// webpack.dev.js
const path = require('path')

const { merge } = require('webpack-merge')

const commonConfig = require('./webpack.common')

module.exports = merge(commonConfig, {
  mode: 'development',
  devtool: 'inline-source-map',
  devServer: {
    static: {
      directory: path.join(__dirname, 'public'),
    },
    port: 9000,
    hot: true,
  },
})
```

- [webpack-merge](https://www.npmjs.com/package/webpack-merge)  
  여러개의 Webpack.config를 하나로 병합. 개발용, 프로덕트용 등으로 분리할 때 적합.
- `devtool: 'inline-source-map'`  
  번들링된 파일에서 디버깅을 하려고 하면 제대로된 위치를 찾을 수 없다. 그 문제를 해결하기 위한 것이 source map이고 [inline-source-map 뿐만 아니라 다양한 설정값](https://webpack.js.org/configuration/devtool/#devtool)들이 존재한다.
- `devServer`  
  `webpack-dev-server`의 설정 객체. 개발 단계에서 실제 번들링 파일을 생성하지 않고, 빌드 결과를 담아 서버에 띄워준다.
- [`path.join(__dirname, 'public'),`](https://p-iknow.netlify.app/node-js/path-moudle/)  
  모듈 관계에서 현재 파일 경로명, 파일명 등을 알아야 하는 상황이 존재. 그 문제를 해결하기 위해 등장. `path.join()`은 인자들을 합쳐서 경로를 만들어줌.
  `__dirname` 은 현재 경로의 디렉토리명까지 만들어줌. 뒤에 붙는 `public`은 `__dirname` 뒤에 public 폴더명을 붙이겠다는 의미.
  결국 devServer 설정은 /public 의 index 파일을 기준으로, port 9000의 서버를 열어주고, 코드 변경 시 즉각 반영하겠다는 뜻.
### 참고 자료
[webpack-boilerplate](https://github.com/doonguk/webpack-boilerplate#step1)
[웹팩 핸드북](https://joshua1988.github.io/webpack-guide/)
[웹팩 공식문서](https://webpack.js.org/)
[바벨 공식문서](https://babeljs.io/docs/en/)

# Plus alpha

- 소개한 기능들 말고도 훨씬 많고 방대한 기능들이 공식문서에 소개가 되어있음. 빙산의 일각임.
- 파일 나누기 (chunk 나누기)
- [tree shaking](https://webpack.js.org/guides/tree-shaking/)
- 또한 컴파일러, 번들러는 바벨, 웹팩말고도 SWC, Vite 등 수 많은 대체제도 존재함. 각각의 차이도 알아보면 좋을 것임.
- 조금 더 공부해보고 싶은 부분은 브라우저 렌더링에 대한 딥다이브.
